[["index.html", "Introduction to Version Control Overview", " Introduction to Version Control Dr. Carl Stahmer and Dr. Tyler Shoemaker 2022-02-03 Overview This workshop covers the fundamentals of using version control for reproducible research. Topics covered will include installing the Git versioning control software locally, initiating a local Git repository, managing file versions, basic branching and merging, and time permitting intermediate topics including working with remote repositories and resolving conflicts. At the end of this workshop learners should be able to create new repos and begin using Git for version control of their individual projects. "],["introduction.html", "1 Introduction 1.1 Interactive Session Information 1.2 About this Tutorial 1.3 Prerequisites 1.4 Learning Objectives", " 1 Introduction This workshop covers the basics of using Git to track and record changes to files on your local computer. This allows you to compare versions over time, recall earlier changes you made, and effectively collaborate on writing code and documents. This is a hybrid workshop. First, read independently work through sections 1-3 of this reader at your own pace and ensure that you have successfully installed Git on your local computer. Next, join us for the live, interactive session (details below), during which we will use Git to learn and practice how to manage files on our local computers.If you need help troubleshooting your installation, drop-in to DataLab’s office hours prior to the interactive session to ensure that you will be able to follow along on your own machine. The full workshop description can be found here. 1.1 Interactive Session Information The workshop includes a live, interactive session to be held via Zoom on Wednesday, February 15, 2021 from 3:00 pm to 5:00 pm. Zoom login information will be sent to all registered participants via email; reach out to datalab-training@ucdavis.edu the day prior if you received a registration confirmation but have not received your Zoom link. 1.2 About this Tutorial This online tutorial provides background information that will help participants to better understand the concepts introduced during the interactive session. It also includes information to help you successfully install Git on your local computer, which must be completed prior to the interactive session. Instructions for installing Git are in section 3. 1.3 Prerequisites In addition to installing Git, we ask that you: Be familiar with your computer’s file navigation system (Finder for Mac, as an example) Have basic facility with using a command line interface, such as Terminal or Git Bash Need to brush up on the command line? The DataLab runs a workshop, “Introduction to the Unix Command Line.” You can find a reader for that at this link; there’s also a recording for this session. 1.4 Learning Objectives Describe the history of version control systems (VCS), including their value and function Explain how a VCS manges files on your computer Successfully install and run Git on your local computer Interact with Git via your computer’s command line Successfully create local repositories and place your files under version control Compare multiple versions of the same file and roll back to earlier versions Perform basic branching and merging operations Identify where to go to learn more "],["version-control.html", "2 Version Control 2.1 What is Version Control? 2.2 Software Assisted Version Control 2.3 Local vs Server-based Version Control 2.4 Central Version Control Systems 2.5 Distributed Version Control Systems 2.6 The Best of Both Worlds 2.7 VCS and the Computer File System 2.8 How Computers Store and Access Information 2.9 How VCS Manage Your Files 2.10 Graph-Based Data Management", " 2 Version Control 2.1 What is Version Control? Version control describes a process of storing and organizing multiple versions (or copies) of documents that you create. Approaches to version control range from simple to complex and can involve the use of various human workflows and/or software applications to accomplish the overall goal of storing and managing multiple versions of the same document(s). Most people have a folder/directory somewhere on their computer that looks something like this: Or perhaps, this: This is a rudimentary form of version control that relies completely on the human workflow of saving multiple versions of a file. This system works minimally well, in that it provides you with a history of file versions theoretically organized by their time sequence. But this file system method offers no information about how the file has changed from version to version, why you might have saved a particular version, or specifically how the various versions are related. This human-managed file system approach is more subject to error than software-assisted version control systems; it is not uncommon for users to make mistakes when naming file versions, or to go back and edit files out of sequence. Software-assisted version control systems (VCS) such as Git were designed to solve this problem. 2.2 Software Assisted Version Control Version control software has its roots in the software development community, where it is common for many coders to work on the same file, sometimes synchronously, amplifying the need to track and understand revisions. But nearly all types of computer files, not just code, can be tracked using modern version control systems. IBM’s OS/360 IEBUPDTE software update tool is widely regarded as the earliest and most widely adopted precursor to modern, version control systems. Its release in 1972 of the Source Code Control System (SCCS) package marked the first, fully fledged system designed specifically for software version control. Today’s marketplace offers many options when it comes to choosing a version control software system. They include systems such as Git, Visual Source Safe, Subversion, Mercurial, CVS, and Plastic SCM, to name a few. Each of these systems offers its twist on version control, differing sometimes in the area of user functionality, sometimes in how it handles things on the back-end, and sometimes both. This tutorial focuses on the Git VCS, but in the sections that follow we offer some general information about classes of version control systems to help you better understand how Git does what it does and to help you make more informed decisions about how to deploy it for you own work. 2.3 Local vs Server-based Version Control There are two general types of version control systems: local and server (sometimes called cloud) based systems. When working with a local version control system, all files, metadata, and everything associated with the version control system live on your local drive in a universe unto itself. Working locally is a perfectly reasonable option for those who work independently (not as part of a team), have no need to regularly share their files or file versions, and who have robust back-up practices for their local storage drive(s). Working locally is also sometimes the only option for projects involving protected data and/or proprietary code that cannot be shared. Server-based VCS utilize software running on your local computer that communicates with a remote server (or servers) that store your files and data. Depending on the system being deployed, files and data may reside exclusively on the server and are downloaded to temporary local storage only when a file is being actively edited. Or, the system may maintain continuous local and remote versions of your files. Server-based systems facilitate team science because they allow multiple users to have access to the same files, and all their respective versions, via the server. They can also provide an important, non-local back-up of your files, protecting you from loss of data should your local storage fail. Git is a free server-based version control system that can store files both locally and on a remote server. While the sections that follow offer a broader description of server-based version control, in this workshop we will focus only on using Git locally and will not configure the software to communicate with, store files on, or otherwise interact with a remote server. DataLab’s companion Git for Teams workshop focuses on using Git with the GitHub cloud service to capitalize on Git’s distributed version control capabilities. Server-based version control systems can generally be segmented into two distinct categories: 1) Centralized Version Control Systems (Centralized VCS) and 2) Distributed Version Control Systems (Distributed VCS). 2.4 Central Version Control Systems Centralized VCS is the oldest and the predominant form of version control architecture worldwide. Centralized VCS implement a “spoke and wheel” architecture to provided server-based version control. With the spoke and wheel architecture, the server maintains a centralized collection of file versions. Users utilize version control clients to “check-out” a file of interest to their local file storage, where they are free to make changes to the file. Centralized VCS typically restrict other users from checking out editable versions of a file if another user currently has the file checked out. Once the user who has checked out the file has finished making changes, they “check-in” their new version, which is then stored on the server from where it can be retrieved and “checked-out” by another user. Taken together, centralized VCS provide a very controlled and ordered universe that ensures file integrity and tracking of changes. However, this regulation comes at a cost: namely, it it reduces the ease with which multiple users can work simultaneously on the same file. 2.5 Distributed Version Control Systems Distributed VCS are not dependent on a central repository as a means of sharing files or tracking versions. Distributed VCS implement a network architecture (as opposed to the spoke and wheel of the centralized VCS as pictured above) to allow each user to communicate directly with every other user. In distributed VCS, each user maintains their own version history of the files being tracked, and the VCS software communicates between users to keep the various local file systems in sync with each other. With this type of system, the local versions of two different users will diverge from each other if both users make changes to the file. This divergence will remain in place until the local repositories are synced, at which time the VCS stitches (or merges) the two different versions of the file into a single version that reflects the changes made by each individual, and then saves the stitched version of the file onto both systems as the current version. Various mechanisms can then be used to resolve the conflicts that may arise during this merge process. Distributed VCS offer greater flexibility and facilitate collaborative work, but a lack of understanding of the sync/merge workflow can cause problems. It is not uncommon for a user to forget to sync their local repository with the repositories of other team members and, as a result, work for extended periods of time on outdated files that don’t reflect their teammates and result in work inefficiencies and merge challenges. 2.6 The Best of Both Worlds An important feature of distributed VCS is that many users and organizations choose to include a central server as a node in the distributed network. This creates an hybrid universe in which some users will sync directly to each other while other users will sync through a central server. Syncing with a cloud-based server provides an extra level of backup for your files and also facilitates communication between users. But treating the server as just another node on the network (as opposed to a centralized point of control) puts the control and flexibility back in the hands of the individual developer. For example, in a true centralized VCS, if the server goes down then nobody can check files in and out of the server, which means that nobody can work. But in a distributed VCS this is not an issue. Users can continue to work on local versions and the system will sync any changes when the server becomes available. Git, the focus of this tutorial, is a Distributed VCS. You can use Git to share and sync repositories directly with other users or through a central Git server such as GitHub or GitLab. 2.7 VCS and the Computer File System When we think about version control, we typically think about managing changes to individual files. From the user perspective, the file is typically the minimum accessible unit of information. Whether working with images, tabular data, or written text, we typically use software to open a file that contains the information we want to view or edit. As such, it comes as a surprise to most users that the concept of files, and their organizing containers (folders or directories), are not intrinsic to how computers themselves store and interact with data. In this section of the tutorial we will learn about how computers store and access information and how VCS interact with this process to track and manage files. 2.8 How Computers Store and Access Information For all of their computing power and seeming intelligence, computers still only know two things: 0 and 1. In computer speak, we call this a binary system, and the unit of memory on a hard-disk, flash drive, or computer chip that stores each 1 or 0 is called a bit.You can think of your computer’s storage device (regardless of what kind it is) as a presenting a large grid, where each box is a bit: In the above example, as with most computer storage, the bits in our storage grid are addressable, meaning that we can designate a particular bit using a row and column number such as, for example, A7, or E12. Also, remember, that each bit can only contain one of two values: 0 or 1. So, in practice, our storage grid would actually look something like this: All of the complex information that we store in the computer is translated to this binary language prior to storage using a system called Unicode. You can think of Unicode as a codebook that assigns a unique combination of 8, 16, 32, 64, etc. (depending on how old your computer is) ones and zeros to each letter, numeral, or symbol. For example, the 8-bit Unicode for the upper case letter “A” is 01000001, and the 8-bit Unicode character for the digit “3” is 00110011. The above grid actually spells out the phrase, “Call me Ishmael”, the opening line of Herman Melville’s novel Moby Dick. An important aspect of how computers story information in binary form is that, unlike most human readable forms of data storage, there is no right to left, up or down, or any other regularized organization of bits on a storage medium. When you save a file on your computer, the computer simply looks for any open bits and starts recording information. The net result is that the contents of single file are frequently randomly interleaved with data from other files. This mode of storage is used because it maximizes the use of open bits on the storage device. But it presents the singular problem of not making data readable in a regularized, linear fashion. To solve this problem, all computers reserve a particular part of their internal memory for a directory that stores a sector map of all chunks of data. For example, if you create a file called README.txt with the word “hello” in it, the computer would randomly store the Unicode for the five characters in the word “hello” on the storage device and make a directory entry something like the following: Understanding the directory concept and how computers store information is crucial to understanding how VCS mange your files. 2.9 How VCS Manage Your Files Most users think about version control as a process of managing files. For example, if I might have a directory called My Project that holds several files related to this project as follows: One approach to managing changes to the above project files would be to store multiple versions of each file as in the figure below for the file analysis.r: In fact, many VCS do exactly this. They treat each file as the minimum unit of data and simply save various versions of each file along with some additional information about the version. This approach can work reasonably well. However, it has limitations. First, this approach can unnecessarily consume space on the local storage device, especially if you are saving many versions of a very large file. It also has difficulty dealing with changes in file names, typically treating the same file with a new name as a completely new file, thereby breaking the chain of version history. To combat these issues, good VCS don’t actually manage files at all. They manage directories. Distributed VCS like Git take this alternate approach to data storage that is directory, rather than file, based. 2.10 Graph-Based Data Management Git (and many other distributed VCS) manage your files as collections of data rather than collections of files. Git’s primary unit of management is the repository, or repo for short, which is aligned with your computer’s directory/folder structure. Consider, for example, the following file structure: Here we see a user, Tom’s, home directory, which contains three sub directories (Data, Thesis, and Tools) and one file (Notes.txt). Both the Data and Tools directories contain sub files and/or directories. If Tom wanted to track changes to the two files in the Data directory, he would first create a Git repository by placing the Data directory under version control. When a repository is created, the Git system writes a collection of hidden files into the data directory that it uses to store information about all of the data that lives under that directory. This includes information about the addition, renaming, and deletion of both files and folders as well as information about changes to the data contained in the files themselves. Additions, deletions and versions of files are tracked and stored not as copies of files, but rather as a set of instructions that describes changes made to the underling data and the directory structure that describes them. "],["installing-git.html", "3 Installing Git 3.1 Git on Windows 3.2 Git on Mac 3.3 Verifying Your Install 3.4 Installation Troubleshooting 3.5 Git on the Command Line 3.6 Ready, Set, Go…", " 3 Installing Git In order to run Git version control and be ready for the interactive session of this workshop, you need to install it on your local machine. This is required preparation and we will not have time during the interactive session to help you troubleshoot installation issues. If you don’t have Git installed, you won’t be able to follow along with the activities. Git installation is typically an easy, point and click process, but there are some configuration steps along the way to which you’ll need to pay attention and thus we recommend that you try this well in advance of the workshop so you have time to troubleshoot your install if necessary. 3.1 Git on Windows Follow these step-by-step instructions if you’re installing Git on a Windows machine: First, launch a web browser, the image below shows the Microsoft Edge browser: Next, navigate to the following Git download URL in your browser https://git-scm/com/downloads: Select “Windows” from the Downloads portion of the Git web page. Git will display the following page and automatically being downloading the correct version of the Git software. If the download doesn’t start automatically, click on the “Click here to download manually link”: When the download is complete, open/Run the downloaded file (will look different in different browsers, but everyone shoudl know how to do this): A screen will appear asking for permissions for the Git application to make changes to your device. Click on the Yes button: Click Next to accept the user license: Leave the default “Destination Location” unchanged (usually C:Files) and hit Next You will see a screen like the one below asking you to “Select Components”: Leave all of the default components selected and also check the boxes next to “Additional Icons” and its sub-item, “On the Desktop”. Your completed configurations window should have the following compenents selected: Additional Icons -&gt; On the Desktop Windows Explorer integration -&gt; Git Bash Here -&gt; Git GUI Here Git LFS (Large File Support) Associate .git* configuration files with default text editor Associate .sh files to be run with Bash And should look like this: After verifying that you have the necessary components selected as per above, hit Next. The next screen will ask you to “Select a Start Menu Folder.” Keep the default value of Git and hit Next: Leave the default “Use Vim (the ubiquitous text editor) as Git’s default editor” selected on the “Choosing the default editor used by Git” screen and hit Next: On the next screen, leave the default “let Git decide” option selected and hit Next: Leave the default “Git from the command line and also from 3rd-party software” selected and hit Next: On the next “Choosing HTTPS transport backend” page leave the default “Use the OpenSSL library” option selected and hit Next: Leave the default “Checkout Windows-style, commit Unix-style line endings” selected on the next page and hit Next: Keep the default “Use MinTTY (the default terminal of MSYS2)” selected on the “Configuring the terminal emulator to use with Git Bash” window and hit Next: Keep the default value of “Default (fast-forward or merge)” on the “Choose the default behavior of ‘git pull’” page and hit Next: Keep the default value of “Git Credential Manager Core” on the “Choose a credential helper” page and hit Next: Keep the default values on the “Configuration extra options” page by keeping “Enable file system caching” checked and “Enable symbolic links” unchecked and then hit Next: Make sure that no options are checked in the “Configuring experimental options” page and hit Install: After you hit this Install button as per above, you will see an install progress screen like the one below: When the install is complete, a new, “Completing the Git Setup Wizard” window like the one below will appear: Make sure that all of the options on this window are unchecked as in the image below and then hit the Finish button: This will complete your installation process. Windows users should verify that when downloading Git for Windows they have also installed Git Bash, which is necessary for working with Git in command line. 3.2 Git on Mac If you are installing Git on a Mac, there is no extra configuration. First, go to the Git download page at https://git-scm.com/download/mac. Once you’re there, you have two options for getting the software on your machine. Install through Xcode (will take a while, but this also installs a whole suite of software development tools, which may be useful to you later on) Install the binary package The first option will take you to Apple’s download page for Xcode. The second will take you to SourceForge. Click “Download” and then run the installer package once it’s finished downloading. If you get an “unknown developer” warning during the install process, follow the instructions at the beginning of the video at https://www.youtube.com/watch?v=__kr-Ew5kbE to help you work through this problem. 3.3 Verifying Your Install Whether you’re installing on Windows or Mac, note that unlike most applications that you’ve installed before, you will not find a “Git” application in your programs or applications directory once the installation is complete. As long as you don’t get an explicit error message during the installation process, you can assume that the software was successfully installed. Git is a command-line application with which you interact using the command-line, which we’ll cover during the interactive session. If you’re already familiar with using command line, you can verify your install by opening the terminal (for Windows that will be Git Bash) and type git --version. You should then see a response of your installed version (e.g., git version 2.12.2.windows.2, or git version 2.12.2.mac.2), and not the error “command not found.” 3.4 Installation Troubleshooting If you are not able to successfully install Git on your own, please attend DataLab’s Virtual Office Hours, which are held every Wednesday from 1:30 to 3:00 pm, to get help with your installation. Click here for more information and to receive a Zoom link. 3.5 Git on the Command Line There are several Graphical User Interfaces that allow you to interact with Git on your computer, but Git is, at heart, a command line interface. The command line offers a text-only, non graphical means of interacting with your computer. In the beginning, all user interaction with the computer happened at the command line. In the current days of graphical user interfaces, using the command line requires you to launch a special program that provides command Line access. Mac users will use an application called “Terminal” which ships by default with the Mac operating system. To launch the Terminal application, go to: Applicaitons -&gt; Utilities -&gt; Terminal When you launch the application, you will see something like this: Windows users will use an application called Git Bash, which was installed on your system when you installed Git. To launch Git Bash, go to: Click on the Windows Start Menu and search for “Git Bash” Alternatively, Click on the Windows Start Menu, select Programs, and browse to Git Bash When you launch the application, you will see something like this: 3.6 Ready, Set, Go… If you’ve read and understood the information in this online tutorial and successfully installed Git on your local machine, you’re ready for the interactive session! The sections that follow present exhibits to which we will refer during the live session. "],["creating-your-first-repo.html", "4 Creating Your First Repo 4.1 Your First Repo 4.2 Checking the Status of a Repo 4.3 Save, Stage, Commit 4.4 View a History of Your Commits 4.5 Comparing Commits 4.6 Comparing Files", " 4 Creating Your First Repo Now that we’ve established how version control works, we can start using it. To do so, we’ll create a new directory under Home and initialize a new Git repository inside it. 4.1 Your First Repo Using the command line, move to your Home directory $ cd ~ Note: The $ character represents your command prompt. You do not need to type it into your terminal. Create a new directory for this workshop $ mkdir intro_to_git Change to the new directory $ cd intro_to_git To put this directory under version control, we simply use $ git init Initialized empty Git repository in /Users/username/intro_to_git/.git/ The message your command line sends back indicates what, exactly, putting a directory under version control means. Notice that Git has created a new, hidden directory inside intro_to_git, called .git. This is the Git repository. It doesn’t contain any information about your files (yet), but it does set up all the necessary files and directories that you need to track a project. $ ls -a .git HEAD config description hooks info objects refs The nice thing about Git is that, for the most part, it automatically interfaces with the contents of the repository. You can mostly ignore them when working on a project; they do the important work of keeping track of what you’ve committed. 4.2 Checking the Status of a Repo With our repository made, we can check its status $ git status On branch master No commits yet nothing to commit (create/copy files and use &quot;git add&quot; to track) That makes sense! We haven’t done anything yet. We’ll discuss some of the pieces of this message in a bit, but first, let’s make a new file. $ echo &quot;Hello world&quot; &gt; hello.txt Now, we could edit this file, if we like. For example, we could open it with a text editor (either with Vim or something else), add an exclamation mark at the end of “world,” and save it. Once we do this, the file will read: $ cat hello.txt Hello world! 4.3 Save, Stage, Commit So far, this should feel very familiar: it’s how you probably interact with your files on a daily basis. But saving a file is not the same thing as tracking it with a VCS. Git does not automatically preserve versions of every save action. When working with Git, you can save as you always do, but this has no impact on the states of this file that are preserved in the repository. To create a version, you must add saved files to a staging area and then commit those staged files to the repository. The commits you make then constitute the versions of those files. As is probably clear, this is a multi-step process: first we save, then we stage, then we commit. Let’s do this with the file we’ve just made. 4.3.1 Step 1: Save the file We’ve already done this, so we can move on. 4.3.2 Step 2: Stage the file We use $ git add hello.txt …to add our file to the staging area. Now, if we run a status check, we’ll see: $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) hello.txt nothing added to commit but untracked files present (use \"git add\" to track) Notice that Git is pretty verbose. Here, it’s telling us that there is an untracked file in the directory. And that makes sense: we’ve made and saved hello.txt but haven’t let Git know that it needs to track this file. To do so, we do exactly what the status message tells us to do $ git add hello.txt When we do another status check $ git status On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: hello.txt …Git tells us that hello.txt is staged. Even now, however, we haven’t made a version of this file. To do so, we need run a commit command. This will create versions of all files in the staging area. 4.3.3 Step 3: Commit the file Typically, we commit our files in one of two ways. The first is just to run $ git commit If you run this, you might be surprised at what happens next. Git dumps you into a command line text editor and asks you to write a message explaining what changes you’ve made to your files. Every commit has a message (or should have one) associated with it, as this helps you track what makes one version different from another. Here’s the message you’ll get if you run the above: # Please enter the commit message for your changes. Lines starting # with &#39;#&#39; will be ignored, and an empty message aborts the commit. # # On branch master # # Initial commit # # Changes to be committed: # new file: hello.txt # All you’d need to do is write your message on the first, empty line and save and quit. This would be the end of the commit. But there’s some shorthand for this, which is the second way to do a commit. You’ll probably find yourself using it more. $ git commit -m &#39;Adding my first file to the repository&#39; Using the -m flag injects your message directly into the commit, without the need for a text editor (don’t include un-escaped apostrophes your message, as this will throw off the message!). This is great for short commits, but if you need to write a longer message about what you’ve changed, use the other method. Whichever method you use, once you commit your file, you should see something like the following: $ git commit -m &#39;Adding my first file to the repository&#39; [master (root-commit) be5fd7e] Adding my first file to the repository 1 file changed, 1 insertion(+) create mode 100644 hello.txt Again, Git is verbose: it shows the message, returns the number of files changed in the commit, and tracks what/how many changes were made (here, “insertion”). Running a status check one last time now shows $ git status On branch master nothing to commit, working tree clean You’re ready to keep working on other parts of the file or project. 4.4 View a History of Your Commits If you’d like to see a history of all the commits in a repository, use $ git log commit be5fd7eca84a745569b7dbc7ce03ae8517ace7c6 (HEAD -&gt; master) Author: YOUR NAME &lt;YOU@EMAIL.COM&gt; Date: DATE OF THE COMMIT Adding my first file to the repository If you want to see the specific changes made in the last commit, use $ git log -p -1 commit be5fd7eca84a745569b7dbc7ce03ae8517ace7c6 (HEAD -&gt; master) Author: YOUR NAME &lt;YOU@EMAIL.COM&gt; Date: DATE OF THE COMMIT Adding my first file to the repository diff --git a/hello.txt b/hello.txt new file mode 100644 index 0000000..cd08755 --- /dev/null +++ b/hello.txt @@ -0,0 +1 @@ +Hello world! This reflects the information we saw when we first committed the file. There’s also a way to see this in a more abbreviated fashion: $ git log --stat commit be5fd7eca84a745569b7dbc7ce03ae8517ace7c6 (HEAD -&gt; master) Author: YOUR NAME &lt;YOU@EMAIL.COM&gt; Date: DATE OF THE COMMIT Adding my first file to the repository hello.txt | 1 + 1 file changed, 1 insertion(+) 4.5 Comparing Commits Let’s make a change to our file and re-commit it. We’ll open the file and, on a new line, add the following: “This is my first Git repo.” The contents of the file now look like: Hello world! This is my first Git repo. Save the file, stage it, and commit it with the message “Explaining why I made this file.” $ git commit -m &#39;Explaining why I made this file&quot; One thing we haven’t talked about yet is the long string of alphanumeric characters in a commit message: commit 259143503862af800a2946381bad30774291f8d9 This string is the unique identifier, or hash, for a commit. You can use it to compare one commit against another. But this hash rather long, so it’s a bit more manageable to get its shortened version with: $ git log --oneline 2591435 (HEAD -&gt; master) Explaining why I made this file be5fd7e Adding my first file to the repository Now, simply copy/paste these two hashes with $ git diff be5fd7e 2591435 diff --git a/hello.txt b/hello.txt index cd08755..6c32fd5 100644 --- a/hello.txt +++ b/hello.txt @@ -1 +1,3 @@ Hello world! + +This is my first Git repo. See the insertions? 4.6 Comparing Files Running git diff on the entire repository will return changes for all files in that commit. If you wanted to look at a commit for a single file, use $ git diff be5fd7e hello.txt or $ git diff be5fd7e:hello.txt 2591435:hello.txt Because we only have one file in our directory, the output of either of these commands will be the same as above. "],["git-branching.html", "5 Git Branching 5.1 Making a Branch 5.2 Making Changes to a Branch 5.3 Checking Out Branches 5.4 Merging Branches 5.5 To View an Earlier Commit 5.6 Fixing Merge Conflicts", " 5 Git Branching One of the most powerful parts of Git is its ability to create multiple, side-by-side versions of the files in a repository. We call these branches. Conceptually, branching a repository creates a copy of the codebase in its current state, which you can work on without affecting the primary version from which it was copied. This allows you (or a team) to work down multiple paths without affecting the main (or another person’s) codebase. Why branch? Well, imagine you have a website, which you track with Git. You’ve published this website, but you’re now receiving feature requests from users. While you’d like to implement these features, you want to work on them separately before deploying them to your website. Here, you’d branch your site, develop your features, and, when you’re ready, merge that branch back into the main site codebase. Voilà! Website 2.0 is launched! 5.1 Making a Branch To see a list of branches in your repository, run $ git branch * master The asterisk tells you which branch you’re on. To create a new branch and switch to it, use $ git checkout -b second_branch Switched to a new branch &#39;second_branch&#39; Now, $ git branch master * second_branch …has the two branches. 5.2 Making Changes to a Branch Let’s add a second file to our branch $ git checkout second_branch Switched to branch &#39;second_branch&#39; $ echo &quot;This is a second file&quot; &gt; new.txt Stage and commit it $ git add new.txt $ git commit -m &#39;Adding a second file [second_branch a41096f] Adding a second file 1 file changed, 1 insertion(+) create mode 100644 new.txt See the two files? $ ls hello.txt new.txt 5.3 Checking Out Branches With our second branch made,we can switch back to, or checkout, the first one $ git checkout master Switched to branch &#39;master&#39; But look, new.txt isn’t there: $ ls hello.txt This is because one branch has different information on it than the other. If you want to bring new.txt over to the first branch, you’ll need to merge your two branches. Note: Be sure to commit any changes you make on a branch before checking another one out. If you don’t, those changes will follow you to the new branch, and it can be a mess to sort out. If you’re not quite ready to commit changes but need to switch branches, you can use git stash to temporarily store them and safely switch branches. Once you’re back on the branch with the un-committed changes, you can use git stash apply to retrieve them from the stash. 5.4 Merging Branches When you merge a branch, Git folds any changes that you made to files in an identified branch into the current working branch. It also adds any new files. When you perform a merge, a new commit will be automatically created to track the merge. To merge branches, commit any changes to the branch you want to merge (which we’ve already done), then checkout the branch into which you want to merge (here, master). Then, execute a merge command. The whole sequence looks like this: $ git checkout master $ git merge new_branch Updating 2591435..a41096f Fast-forward new.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 new.txt The “fast-forward” here means that we’ve been able to merge our branches without any conflicts (more on unsuccessful merges in a minute). Now, $ ls hello.txt new.txt …shows both files. Note too that the log on master has been updated: $ git log --oneline a41096f (HEAD -&gt; master, second_branch) Adding a second file 2591435 Explaining why I made this file be5fd7e Adding my first file to the repository 5.5 To View an Earlier Commit The logic of git checkout also applies to looking at older commits on a single branch. If you wanted to go back to the very first commit on master, you could use $ git checkout be5fd7e You’ll likely get a long message from Git: You are in ‘detached HEAD’ state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. The HEAD of your repository is the most recent commit on the branch. As the message above indicates, any changes you make in this detached state will not directly affect other commits. If you’re just looking around and don’t want to make any changes, you can reset to the HEAD with $ git checkout master …which will bring you back to the most recent commit. But say, for example, you preserve some of the information in that earlier commit. You can do so by putting it on a new branch: $ git checkout -b first_commit $ git branch * first_commit master second_branch If you look inside: $ ls hello.txt …there’s a single file, the contents of which: $ cat hello.txt Hello world! …pertain only to that very first commit we made. 5.6 Fixing Merge Conflicts Let’s open hello.txt and, on a new line, add the following: “This is an old version of this file.” The whole file should look like Hello world! This is an old version of this file. Save it, stage it, and commit with a message. $ git add hello.txt $ git commit -m &#39;Explaining which version this is.&#39; All’s well so far. But say you want to merge this file into master. Remember that, on master, this file reads: Hello world! This is my first Git repo. There are two different versions of this file, so if you run a merge from first_commit to master… $ git checkout master $ git merge first_commit Auto-merging hello.txt CONFLICT (content): Merge conflict in hello.txt Automatic merge failed; fix conflicts and then commit the result. …you’ll get a merge conflict. This means that Git is unable to merge the two branches because they have different data in the same area of the file (Git is usually quite good at merging file versions when their differences are in separate areas). We need to resolve these differences manually before Git can merge. To do so, open hello.txt. When you do, you’ll see this: Hello world! &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD This is my first Git repo. ======= This is an old version of this file. &gt;&gt;&gt;&gt;&gt;&gt;&gt; first_commit Git has injected new text into this file, showing you where exactly the conflict lies. It also marks which branch has what information (HEAD for master and first_commit for first_commit). Fixing the merge conflict involves deleting the entire section marked off by &lt;&lt;&lt;&lt;&lt;&lt;&lt; and &gt;&gt;&gt;&gt;&gt;&gt;&gt; and replacing it with the information you’d like the final, merged file to retain. For us, we’ll use the HEAD information. Once you’ve made those changes, your file should look like this: Hello world! This is my first Git repo. Save the changes and run a status check. It should show $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add ...\" to mark resolution) both modified: hello.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") If you add hello.txt and check the repository status again $ git add hello.txt $ git status On branch master All conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge) You’ll see that your conflicts are resolved. With that done, you can complete the merge with a final commit. $ git commit -m &#39;Fixing conflict between master and first_commit&#39; [master b3af7fd] Fixing conflict between master and first_commit Looking once more at the contents of hello.txt will show which changes you implemented Hello world! This is my first Git repo. And the Git log will have separate entries for the merge conflict and for the file from any other branches into which you merged master $ git log --oneline b3af7fd (HEAD -&gt; master) Fixing conflict between master and first_commit f91603a (first_commit) Explaining which version this is. a41096f (second_branch) Adding a second file 2591435 Explaining why I made this file be5fd7e Adding my first file to the repository You can now keep working! "],["troubleshooting-problems-and-fixing-mistakes.html", "6 Troubleshooting Problems and Fixing Mistakes 6.1 Undoing Things 6.2 Hard Resets 6.3 Deleting Files", " 6 Troubleshooting Problems and Fixing Mistakes 6.1 Undoing Things Merge conflicts are some of the most common hiccups you’ll encounter with Git, but there are a few others. We’ll discuss them briefly here. If you forget to add a file to a commit, or you mess up your commit message, you can redo the commit. Stage the files you forgot and commit again using the --amend flag $ git commit --amend If you decide you aren’t ready to commit a staged file, you can un-stage it with $ git reset HEAD &lt;file&gt; or with $ git restore --staged &lt;file&gt; You can reset all uncommitted changes made to a file with $ git checkout -- &lt;file&gt; 6.2 Hard Resets Here’s how you roll everything in a directory back to the last commit $ git reset --hard HEAD Rolling everything back to the next to last commit (the commit before the HEAD commit) $ git reset --hard HEAD^ Rolling everything back to two commits before HEAD $ git reset --hard HEAD^2 And finally, rolling everything back to an identified commit using a hash from the log $ git reset --hard &lt;hash&gt; To reset everything back to an earlier commit and make sure that the HEAD pointer is pointing to the newly reset HEAD, do the following $ git reset --hard &lt;hash&gt; $ git reset --soft HEAD@{1} 6.3 Deleting Files If you’d like to delete a file from Git, use $ git rm &lt;file&gt; Note that this will also delete the file from your file system. If you want to keep the file on your computer, use $ git rm --cached &lt;file&gt; Make a commit to the repository and Git will delete the file. And with all that, you’re ready to start using Git in your own projects! "],["additional-resources.html", "7 Additional Resources 7.1 Git for Teams 7.2 The Git Book", " 7 Additional Resources 7.1 Git for Teams Be on the lookout for the second workshop in DataLab’s Git workshop series, which covers the process of using Git to work with teams performing collaborative development. 7.2 The Git Book The Git Book is the definitive Git resource and provides an excellent reference for everything that we will cover in the interactive session. There is no need to read the book prior to the session, but it’s a good reference resource to have avaialable as you begin to work with Git after the workshop. "]]
